
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "benchmarks/statevec.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_benchmarks_statevec.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_benchmarks_statevec.py:


Statevec
====

Here we take benchmarking for remove_qubit method in Statevec class.

This benchmark measures the time taken to remove single qubit from a statevector.
The methods we use are the followings:
    1. :meth:`~graphix.sim.statevec.Statevec.remove_qubit`
        Optimized method to remove single qubit.
    2. :meth:`~graphix.sim.statevec.Statevec.ptrace`
        Old method to remove multiple qubits.
    3. :meth:`~graphix.pattern.Pattern.simulate_pattern`
        Circuit simulation using pattern matching.

.. GENERATED FROM PYTHON SOURCE LINES 18-19

Firstly, let us import relevant modules:

.. GENERATED FROM PYTHON SOURCE LINES 19-28

.. code-block:: default


    from time import perf_counter
    import matplotlib.pyplot as plt
    import numpy as np
    from graphix import Circuit
    from graphix.clifford import CLIFFORD_MUL
    from graphix.sim.statevec import Statevec, StatevectorBackend, meas_op









.. GENERATED FROM PYTHON SOURCE LINES 29-30

Next, we define the simulation runner:

.. GENERATED FROM PYTHON SOURCE LINES 30-53

.. code-block:: default



    def run(backend):
        """Perform MBQC simulation"""
        for cmd in backend.pattern.seq:
            if cmd[0] == "N":
                backend.add_nodes([cmd[1]])
            elif cmd[0] == "E":
                backend.entangle_nodes(cmd[1])
            elif cmd[0] == "M":
                backend.measure(cmd)
            elif cmd[0] == "X":
                backend.correct_byproduct(cmd)
            elif cmd[0] == "Z":
                backend.correct_byproduct(cmd)
            elif cmd[0] == "C":
                backend.apply_clifford(cmd)
            else:
                raise ValueError("invalid commands")
            if backend.pattern.seq[-1] == cmd:
                backend.finalize()









.. GENERATED FROM PYTHON SOURCE LINES 54-55

Then, we define a random circuit generator:

.. GENERATED FROM PYTHON SOURCE LINES 55-90

.. code-block:: default



    def random_circuit(nqubit, depth, seed=None):
        r"""Generate a random circuit.

        This function generates a random circuit with nqubit qubits and depth layers.
        The circuit is generated by CNOT gates and RZ gates.

        Parameters
        ----------
        nqubit : int
            number of qubits
        depth : int
            number of layers
        seed : int
            random seed

        Returns
        -------
        circuit : graphix.transpiler.Circuit object
            generated circuit
        """
        if seed is not None:
            np.random.seed(seed)
        qubit_index = [i for i in range(nqubit)]
        circuit = Circuit(nqubit)
        for _ in range(depth):
            np.random.shuffle(qubit_index)
            for j in range(len(qubit_index) // 2):
                circuit.cnot(qubit_index[2 * j], qubit_index[2 * j + 1])
            for j in range(len(qubit_index)):
                circuit.rz(qubit_index[j], 2 * np.pi * np.random.random())
        return circuit









.. GENERATED FROM PYTHON SOURCE LINES 91-92

We define the test cases: shallow (depth=1) random circuits, only changing the number of qubits.

.. GENERATED FROM PYTHON SOURCE LINES 92-98

.. code-block:: default


    test_cases = [(i, 1) for i in range(2, 24)]

    pattern_time = []
    circuit_time = []








.. GENERATED FROM PYTHON SOURCE LINES 99-102

We then run simulations.
First, we run the pattern simulations with :meth:`~graphix.sim.statevec.Statevec.remove_qubit`
and circuit simulation:

.. GENERATED FROM PYTHON SOURCE LINES 102-122

.. code-block:: default


    for case in test_cases:
        nqubit, depth = case
        circuit = random_circuit(nqubit, depth)
        pattern = circuit.transpile()
        pattern.standardize()
        pattern.minimize_space()
        max_qubit_num = 20 if nqubit < 20 else 50
        backend = StatevectorBackend(pattern, max_qubit_num=max_qubit_num)
        print(f"max space for nqubit={nqubit} circuit is ", pattern.max_space())
        start = perf_counter()
        run(backend)
        end = perf_counter()
        print(f"nqubit: {nqubit}, depth: {depth}, time: {end - start}")
        pattern_time.append(end - start)
        start = perf_counter()
        circuit.simulate_statevector()
        end = perf_counter()
        circuit_time.append(end - start)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    max space for nqubit=2 circuit is  3
    nqubit: 2, depth: 1, time: 0.002137670002412051
    max space for nqubit=3 circuit is  4
    nqubit: 3, depth: 1, time: 0.002620729002956068
    max space for nqubit=4 circuit is  5
    nqubit: 4, depth: 1, time: 0.0032317069999407977
    max space for nqubit=5 circuit is  6
    nqubit: 5, depth: 1, time: 0.006397109998943051
    max space for nqubit=6 circuit is  7
    nqubit: 6, depth: 1, time: 0.0058759350031323265
    max space for nqubit=7 circuit is  8
    nqubit: 7, depth: 1, time: 0.004786573001183569
    max space for nqubit=8 circuit is  9
    nqubit: 8, depth: 1, time: 0.006532778999826405
    max space for nqubit=9 circuit is  10
    nqubit: 9, depth: 1, time: 0.0064809089999471325
    max space for nqubit=10 circuit is  11
    nqubit: 10, depth: 1, time: 0.00937976600107504
    max space for nqubit=11 circuit is  12
    nqubit: 11, depth: 1, time: 0.015783257000293816
    max space for nqubit=12 circuit is  13
    nqubit: 12, depth: 1, time: 0.014106451999396086
    max space for nqubit=13 circuit is  14
    nqubit: 13, depth: 1, time: 0.0382957539986819
    max space for nqubit=14 circuit is  15
    nqubit: 14, depth: 1, time: 0.060570551999262534
    max space for nqubit=15 circuit is  16
    nqubit: 15, depth: 1, time: 0.192690361996938
    max space for nqubit=16 circuit is  17
    nqubit: 16, depth: 1, time: 0.5203898489999119
    max space for nqubit=17 circuit is  18
    nqubit: 17, depth: 1, time: 0.9899787930007733
    max space for nqubit=18 circuit is  19
    nqubit: 18, depth: 1, time: 1.990603016998648
    max space for nqubit=19 circuit is  20
    nqubit: 19, depth: 1, time: 3.098073723998823
    max space for nqubit=20 circuit is  21
    nqubit: 20, depth: 1, time: 7.614995962998364
    max space for nqubit=21 circuit is  22
    nqubit: 21, depth: 1, time: 12.785936011998274
    max space for nqubit=22 circuit is  23
    nqubit: 22, depth: 1, time: 25.372865347999323
    max space for nqubit=23 circuit is  24
    nqubit: 23, depth: 1, time: 46.41691837699909




.. GENERATED FROM PYTHON SOURCE LINES 123-125

To test old method :meth:`~graphix.sim.statevec.Statevec.ptrace`,
we need to overwrite the class :class:`~graphix.sim.statevec.StatevectorBackend`'

.. GENERATED FROM PYTHON SOURCE LINES 125-194

.. code-block:: default



    class OldStatevectorBackend(StatevectorBackend):
        def add_nodes(self, nodes):
            """add new qubit to internal statevector
            and assign the corresponding node number
            to list self.node_index.
            Parameters
            ----------
            nodes : list of node indices
            """
            if not self.state:
                self.state = Statevec(nqubit=0)
            n = len(nodes)
            sv_to_add = Statevec(nqubit=n)
            self.state.tensor(sv_to_add)
            self.node_index.extend(nodes)
            self.Nqubit += n
            if self.Nqubit == self.max_qubit_num:
                self.trace_out()

        def measure(self, cmd):
            """Perform measurement of a node in the internal statevector and trace out the qubit

            Parameters
            ----------
            cmd : list
                measurement command : ['M', node, plane angle, s_domain, t_domain]
            """
            # choose the measurement result randomly
            result = np.random.choice([0, 1])
            self.results[cmd[1]] = result

            # extract signals for adaptive angle
            s_signal = np.sum([self.results[j] for j in cmd[4]])
            t_signal = np.sum([self.results[j] for j in cmd[5]])
            angle = cmd[3] * np.pi
            if len(cmd) == 7:
                vop = cmd[6]
            else:
                vop = 0
            if int(s_signal % 2) == 1:
                vop = CLIFFORD_MUL[1, vop]
            if int(t_signal % 2) == 1:
                vop = CLIFFORD_MUL[3, vop]
            m_op = meas_op(angle, vop=vop, plane=cmd[2], choice=result)
            loc = self.node_index.index(cmd[1])
            self.state.evolve_single(m_op, loc)

            self.to_trace.append(cmd[1])
            self.to_trace_loc.append(loc)

        def finalize(self):
            """to be run at the end of pattern simulation."""
            self.trace_out()
            self.sort_qubits()
            self.state.normalize()

        def trace_out(self):
            """trace out the qubits buffered in self.to_trace from self.state"""
            self.state.normalize()
            self.state.ptrace(self.to_trace_loc)
            for node in self.to_trace:
                self.node_index.remove(node)
            self.Nqubit -= len(self.to_trace)
            self.to_trace = []
            self.to_trace_loc = []









.. GENERATED FROM PYTHON SOURCE LINES 195-196

Lastly, run the simulation with the old method :meth:`~graphix.sim.statevec.Statevec.ptrace`:

.. GENERATED FROM PYTHON SOURCE LINES 196-215

.. code-block:: default


    test_cases_old = [(i, 1) for i in range(2, 11)]

    old_pattern_time = []

    for case in test_cases_old:
        nqubit, depth = case
        circuit = random_circuit(nqubit, depth)
        pattern = circuit.transpile()
        pattern.standardize()
        pattern.minimize_space()
        print(f"max space for nqubit={nqubit} circuit is ", pattern.max_space())
        old_backend = OldStatevectorBackend(pattern)
        start = perf_counter()
        run(old_backend)
        end = perf_counter()
        print(f"nqubit: {nqubit}, depth: {depth}, time: {end - start}")
        old_pattern_time.append(end - start)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    max space for nqubit=2 circuit is  3
    nqubit: 2, depth: 1, time: 0.003677274999063229
    max space for nqubit=3 circuit is  4
    nqubit: 3, depth: 1, time: 0.004859751999902073
    max space for nqubit=4 circuit is  5
    nqubit: 4, depth: 1, time: 0.2954218099985155
    max space for nqubit=5 circuit is  6
    nqubit: 5, depth: 1, time: 0.5087413630026276
    max space for nqubit=6 circuit is  7
    nqubit: 6, depth: 1, time: 1.1030485379997117
    max space for nqubit=7 circuit is  8
    nqubit: 7, depth: 1, time: 1.6237341099986224
    max space for nqubit=8 circuit is  9
    nqubit: 8, depth: 1, time: 1.5577711670011922
    max space for nqubit=9 circuit is  10
    nqubit: 9, depth: 1, time: 4.040235006999865
    max space for nqubit=10 circuit is  11
    nqubit: 10, depth: 1, time: 36.42544951799937




.. GENERATED FROM PYTHON SOURCE LINES 216-217

plot the pattern_time

.. GENERATED FROM PYTHON SOURCE LINES 217-230

.. code-block:: default

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.scatter([case[0] for case in test_cases_old], old_pattern_time, label="pattern simulator with ptrace(old)")
    ax.scatter([case[0] for case in test_cases], pattern_time, label="pattern simulator with remove_qubit(new)")
    ax.scatter([case[0] for case in test_cases], circuit_time, label="circuit simulator")
    ax.set(
        xlabel="nqubit",
        ylabel="time (s)",
        yscale="log",
        title="Time to simulate random circuits",
    )
    fig.legend(bbox_to_anchor=(0.6, 0.9))
    fig.show()



.. image-sg:: /benchmarks/images/sphx_glr_statevec_001.png
   :alt: Time to simulate random circuits
   :srcset: /benchmarks/images/sphx_glr_statevec_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  31.275 seconds)


.. _sphx_glr_download_benchmarks_statevec.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: statevec.py <statevec.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: statevec.ipynb <statevec.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
